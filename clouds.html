<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clouds - Shader Demo</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }

      body {
        width: 100%;
        height: 100vh;
        overflow: hidden;
        background: #f5f0f8;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      #back-button {
        position: absolute;
        top: 20px;
        left: 20px;
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        z-index: 10;
      }

      #back-button:hover {
        background: rgba(255, 255, 255, 1);
      }
    </style>
  </head>
  <body>
    <button id="back-button">‚Üê Back</button>
    <canvas id="canvas"></canvas>

    <script>
      document.getElementById("back-button").addEventListener("click", () => {
        window.location.href = "index.html";
      });

      const vertexShader = `
            precision highp float;
            attribute vec2 position;
            
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

      const fragmentShader = `
            precision highp float;
            uniform vec2 resolution;
            uniform float time;
            
            // Perlin-like noise
            float hash(vec2 p) {
                float h = dot(p, vec2(127.1, 311.7));
                return fract(sin(h) * 43758.5453123);
            }
            
            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                
                float n00 = hash(i + vec2(0.0, 0.0));
                float n10 = hash(i + vec2(1.0, 0.0));
                float n01 = hash(i + vec2(0.0, 1.0));
                float n11 = hash(i + vec2(1.0, 1.0));
                
                float nx0 = mix(n00, n10, f.x);
                float nx1 = mix(n01, n11, f.x);
                return mix(nx0, nx1, f.y);
            }
            
            // Fractal Brownian Motion for clouds
            float fbm(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 1.0;
                
                for (int i = 0; i < 7; i++) {
                    value += amplitude * noise(p * frequency + time * 0.15);
                    amplitude *= 0.5;
                    frequency *= 2.0;
                }
                
                return value;
            }
            
            // Simulate audio reactivity
            float audioSimulation(float t) {
                float pulse = sin(t * 0.5) * 0.3;
                pulse += sin(t * 0.3 + 5.0) * 0.2;
                return 0.7 + pulse;
            }
            
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec2 p = uv * 2.0 - 1.0;
                p.x *= resolution.x / resolution.y;
                
                // Get the cloud value using FBM with more contrast
                float cloudDensity = fbm(p * 3.0);
                cloudDensity = smoothstep(0.40, 0.60, cloudDensity);
                
                // Add some lower frequency clouds for larger shapes
                float largeCloud = fbm(p * 1.5);
                largeCloud = smoothstep(0.30, 0.70, largeCloud);
                
                // Combine for fluffy appearance
                float cloud = mix(cloudDensity, largeCloud, 0.5);
                
                // Fade edges
                float edgeFade = distance(uv, vec2(0.5, 0.5));
                edgeFade = smoothstep(0.65, 0.25, edgeFade);
                cloud *= edgeFade;
                
                // Base light background - more pink
                vec3 bgColor = vec3(0.97, 0.92, 0.96);
                
                // Pink gradation based on cloud density - shifted toward pink
                vec3 cloudColor = mix(bgColor, vec3(0.90, 0.58, 0.82), cloud * 0.7);
                cloudColor = mix(cloudColor, vec3(0.82, 0.28, 0.65), cloud * cloud * 0.8);
                
                gl_FragColor = vec4(cloudColor, 1.0);
            }
        `;

      const canvas = document.getElementById("canvas");
      const gl = canvas.getContext("webgl", { antialias: true });

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
        }
        return shader;
      }

      const vShader = compileShader(vertexShader, gl.VERTEX_SHADER);
      const fShader = compileShader(fragmentShader, gl.FRAGMENT_SHADER);
      const program = gl.createProgram();
      gl.attachShader(program, vShader);
      gl.attachShader(program, fShader);
      gl.linkProgram(program);
      gl.useProgram(program);

      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
        gl.STATIC_DRAW,
      );

      const posLocation = gl.getAttribLocation(program, "position");
      gl.enableVertexAttribArray(posLocation);
      gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);

      const resolutionLoc = gl.getUniformLocation(program, "resolution");
      const timeLoc = gl.getUniformLocation(program, "time");

      const startTime = Date.now();

      function animate() {
        const elapsed = (Date.now() - startTime) * 0.001;

        gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
        gl.uniform1f(timeLoc, elapsed);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>
